// Generated protobuf code from intelligence.proto
// This is generated by build.rs using tonic-prost-build

// Wrap the generated code in the expected module structure
pub mod opentier {
    pub mod intelligence {
        pub mod v1 {
            // Include the generated proto code
            // The file is generated in OUT_DIR during build
            include!(concat!(env!("OUT_DIR"), "/opentier.intelligence.v1.rs"));
        }
    }
}


// pub mod opentier {
//     pub mod intelligence {
//         pub mod v1 {
//             // Service
//             pub mod chat_client {
//                 use tonic::transport::Channel;
//                 #[derive(Clone)]
//                 pub struct ChatClient<T> {
//                     inner: T,
//                 }

//                 impl ChatClient<Channel> {
//                     pub fn new(inner: Channel) -> Self {
//                         Self { inner }
//                     }

//                     pub async fn send_message(
//                         &mut self,
//                         request: tonic::Request<super::ChatRequest>,
//                     ) -> Result<tonic::Response<super::ChatResponse>, tonic::Status>
//                     {
//                         unimplemented!()
//                     }

//                     pub async fn stream_chat(
//                         &mut self,
//                         request: tonic::Request<super::ChatRequest>,
//                     ) -> Result<
//                         tonic::Response<tonic::codec::Streaming<super::ChatStreamChunk>>,
//                         tonic::Status,
//                     > {
//                         unimplemented!()
//                     }

//                     pub async fn get_conversation(
//                         &mut self,
//                         request: tonic::Request<super::GetConversationRequest>,
//                     ) -> Result<tonic::Response<super::ConversationResponse>, tonic::Status>
//                     {
//                         unimplemented!()
//                     }

//                     pub async fn delete_conversation(
//                         &mut self,
//                         request: tonic::Request<super::DeleteConversationRequest>,
//                     ) -> Result<tonic::Response<super::DeleteConversationResponse>, tonic::Status>
//                     {
//                         unimplemented!()
//                     }
//                 }
//             }

//             // Chat Messages
//             #[derive(Clone, PartialEq, ::prost::Message)]
//             pub struct ChatRequest {
//                 #[prost(string, tag = "1")]
//                 pub user_id: String,
//                 #[prost(string, tag = "2")]
//                 pub conversation_id: String,
//                 #[prost(string, tag = "3")]
//                 pub message: String,
//                 #[prost(message, optional, tag = "4")]
//                 pub config: Option<ChatConfig>,
//             }

//             #[derive(Clone, PartialEq, ::prost::Message)]
//             pub struct ChatConfig {
//                 #[prost(float, optional, tag = "1")]
//                 pub temperature: Option<f32>,
//                 #[prost(int32, optional, tag = "2")]
//                 pub max_tokens: Option<i32>,
//                 #[prost(bool, optional, tag = "3")]
//                 pub use_rag: Option<bool>,
//                 #[prost(string, optional, tag = "5")]
//                 pub model: Option<String>,
//             }

//             #[derive(Clone, PartialEq, ::prost::Message)]
//             pub struct ChatResponse {
//                 #[prost(string, tag = "1")]
//                 pub conversation_id: String,
//                 #[prost(string, tag = "2")]
//                 pub message_id: String,
//                 #[prost(string, tag = "3")]
//                 pub response: String,
//                 #[prost(message, repeated, tag = "4")]
//                 pub sources: Vec<ContextChunk>,
//                 #[prost(message, optional, tag = "5")]
//                 pub metrics: Option<ChatMetrics>,
//                 #[prost(int64, tag = "6")]
//                 pub created_at: i64,
//             }

//             #[derive(Clone, PartialEq, ::prost::Message)]
//             pub struct ContextChunk {
//                 #[prost(string, tag = "1")]
//                 pub chunk_id: String,
//                 #[prost(string, tag = "2")]
//                 pub document_id: String,
//                 #[prost(string, tag = "3")]
//                 pub content: String,
//                 #[prost(float, tag = "4")]
//                 pub relevance_score: f32,
//             }

//             #[derive(Clone, PartialEq, ::prost::Message)]
//             pub struct ChatMetrics {
//                 #[prost(int32, tag = "1")]
//                 pub tokens_used: i32,
//                 #[prost(int32, tag = "2")]
//                 pub prompt_tokens: i32,
//                 #[prost(int32, tag = "3")]
//                 pub completion_tokens: i32,
//                 #[prost(float, tag = "4")]
//                 pub latency_ms: f32,
//                 #[prost(int32, tag = "5")]
//                 pub sources_retrieved: i32,
//             }

//             #[derive(Clone, PartialEq, ::prost::Message)]
//             pub struct ChatStreamChunk {
//                 #[prost(string, tag = "1")]
//                 pub conversation_id: String,
//                 #[prost(string, tag = "2")]
//                 pub message_id: String,
//                 #[prost(oneof = "chat_stream_chunk::ChunkType", tags = "3, 4, 5, 6")]
//                 pub chunk_type: Option<chat_stream_chunk::ChunkType>,
//                 #[prost(bool, tag = "7")]
//                 pub is_final: bool,
//             }

//             pub mod chat_stream_chunk {
//                 #[derive(Clone, PartialEq, ::prost::Oneof)]
//                 pub enum ChunkType {
//                     #[prost(string, tag = "3")]
//                     Token(String),
//                     #[prost(message, tag = "4")]
//                     Source(super::ContextChunk),
//                     #[prost(message, tag = "5")]
//                     Metrics(super::ChatMetrics),
//                     #[prost(string, tag = "6")]
//                     Error(String),
//                 }
//             }

//             #[derive(Clone, PartialEq, ::prost::Message)]
//             pub struct GetConversationRequest {
//                 #[prost(string, tag = "1")]
//                 pub user_id: String,
//                 #[prost(string, tag = "2")]
//                 pub conversation_id: String,
//                 #[prost(int32, optional, tag = "3")]
//                 pub limit: Option<i32>,
//                 #[prost(string, optional, tag = "4")]
//                 pub cursor: Option<String>,
//             }

//             #[derive(Clone, PartialEq, ::prost::Message)]
//             pub struct ConversationResponse {
//                 #[prost(string, tag = "1")]
//                 pub conversation_id: String,
//                 #[prost(message, repeated, tag = "2")]
//                 pub messages: Vec<ChatMessage>,
//                 #[prost(string, optional, tag = "3")]
//                 pub next_cursor: Option<String>,
//                 #[prost(int64, tag = "4")]
//                 pub created_at: i64,
//                 #[prost(int64, tag = "5")]
//                 pub updated_at: i64,
//             }

//             #[derive(Clone, PartialEq, ::prost::Message)]
//             pub struct ChatMessage {
//                 #[prost(string, tag = "1")]
//                 pub message_id: String,
//                 #[prost(enumeration = "MessageRole", tag = "2")]
//                 pub role: i32,
//                 #[prost(string, tag = "3")]
//                 pub content: String,
//                 #[prost(message, repeated, tag = "4")]
//                 pub sources: Vec<ContextChunk>,
//                 #[prost(int64, tag = "5")]
//                 pub created_at: i64,
//             }

//             #[derive(
//                 Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration,
//             )]
//             #[repr(i32)]
//             pub enum MessageRole {
//                 Unspecified = 0,
//                 User = 1,
//                 Assistant = 2,
//                 System = 3,
//             }

//             #[derive(Clone, PartialEq, ::prost::Message)]
//             pub struct DeleteConversationRequest {
//                 #[prost(string, tag = "1")]
//                 pub user_id: String,
//                 #[prost(string, tag = "2")]
//                 pub conversation_id: String,
//             }

//             #[derive(Clone, PartialEq, ::prost::Message)]
//             pub struct DeleteConversationResponse {
//                 #[prost(bool, tag = "1")]
//                 pub success: bool,
//                 #[prost(string, tag = "2")]
//                 pub conversation_id: String,
//             }

//             // Resource Service
//             pub mod resource_client {
//                 use tonic::transport::Channel;
//                 #[derive(Clone)]
//                 pub struct ResourceClient<T> {
//                     inner: T,
//                 }

//                 impl ResourceClient<Channel> {
//                     pub fn new(inner: Channel) -> Self {
//                         Self { inner }
//                     }

//                     pub async fn add_resource(
//                         &mut self,
//                         request: tonic::Request<super::AddResourceRequest>,
//                     ) -> Result<tonic::Response<super::AddResourceResponse>, tonic::Status>
//                     {
//                         unimplemented!()
//                     }

//                     pub async fn get_resource_status(
//                         &mut self,
//                         request: tonic::Request<super::GetResourceStatusRequest>,
//                     ) -> Result<tonic::Response<super::ResourceStatusResponse>, tonic::Status>
//                     {
//                         unimplemented!()
//                     }

//                     pub async fn delete_resource(
//                         &mut self,
//                         request: tonic::Request<super::DeleteResourceRequest>,
//                     ) -> Result<tonic::Response<super::DeleteResourceResponse>, tonic::Status>
//                     {
//                         unimplemented!()
//                     }
//                 }
//             }

//             // Resource Messages
//             #[derive(Clone, PartialEq, ::prost::Message)]
//             pub struct AddResourceRequest {
//                 #[prost(string, tag = "1")]
//                 pub user_id: String,
//                 #[prost(string, tag = "2")]
//                 pub resource_id: String,
//                 #[prost(oneof = "add_resource_request::Content", tags = "3, 4, 5")]
//                 pub content: Option<add_resource_request::Content>,
//                 #[prost(enumeration = "ResourceType", tag = "6")]
//                 pub r#type: i32,
//                 #[prost(string, optional, tag = "7")]
//                 pub title: Option<String>,
//                 #[prost(map = "string, string", tag = "8")]
//                 pub metadata: ::std::collections::HashMap<String, String>,
//                 #[prost(message, optional, tag = "9")]
//                 pub config: Option<IngestionConfig>,
//             }

//             pub mod add_resource_request {
//                 #[derive(Clone, PartialEq, ::prost::Oneof)]
//                 pub enum Content {
//                     #[prost(string, tag = "3")]
//                     Text(String),
//                     #[prost(string, tag = "4")]
//                     Url(String),
//                     #[prost(bytes, tag = "5")]
//                     FileContent(Vec<u8>),
//                 }
//             }

//             #[derive(Clone, PartialEq, ::prost::Message)]
//             pub struct IngestionConfig {
//                 #[prost(int32, optional, tag = "1")]
//                 pub chunk_size: Option<i32>,
//                 #[prost(int32, optional, tag = "2")]
//                 pub chunk_overlap: Option<i32>,
//                 #[prost(bool, optional, tag = "3")]
//                 pub auto_clean: Option<bool>,
//                 #[prost(bool, optional, tag = "4")]
//                 pub generate_embeddings: Option<bool>,
//                 #[prost(int32, optional, tag = "5")]
//                 pub max_depth: Option<i32>,
//                 #[prost(bool, optional, tag = "6")]
//                 pub follow_links: Option<bool>,
//             }

//             #[derive(Clone, PartialEq, ::prost::Message)]
//             pub struct AddResourceResponse {
//                 #[prost(string, tag = "1")]
//                 pub job_id: String,
//                 #[prost(string, tag = "2")]
//                 pub resource_id: String,
//                 #[prost(enumeration = "ResourceStatus", tag = "3")]
//                 pub status: i32,
//             }

//             #[derive(Clone, PartialEq, ::prost::Message)]
//             pub struct GetResourceStatusRequest {
//                 #[prost(string, tag = "1")]
//                 pub job_id: String,
//                 #[prost(string, tag = "2")]
//                 pub resource_id: String,
//                 #[prost(string, tag = "3")]
//                 pub user_id: String,
//             }

//             #[derive(Clone, PartialEq, ::prost::Message)]
//             pub struct ResourceStatusResponse {
//                 #[prost(string, tag = "1")]
//                 pub job_id: String,
//                 #[prost(string, tag = "2")]
//                 pub resource_id: String,
//                 #[prost(enumeration = "ResourceStatus", tag = "3")]
//                 pub status: i32,
//                 #[prost(int32, tag = "4")]
//                 pub chunks_created: i32,
//                 #[prost(string, optional, tag = "5")]
//                 pub error: Option<String>,
//                 #[prost(float, tag = "6")]
//                 pub progress: f32,
//             }

//             #[derive(Clone, PartialEq, ::prost::Message)]
//             pub struct DeleteResourceRequest {
//                 #[prost(string, tag = "1")]
//                 pub user_id: String,
//                 #[prost(string, tag = "2")]
//                 pub resource_id: String,
//             }

//             #[derive(Clone, PartialEq, ::prost::Message)]
//             pub struct DeleteResourceResponse {
//                 #[prost(bool, tag = "1")]
//                 pub success: bool,
//                 #[prost(string, tag = "2")]
//                 pub resource_id: String,
//             }

//             #[derive(
//                 Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration,
//             )]
//             #[repr(i32)]
//             pub enum ResourceType {
//                 Unspecified = 0,
//                 Text = 1,
//                 Markdown = 2,
//                 Pdf = 3,
//                 Html = 4,
//                 Website = 5,
//                 Code = 6,
//             }

//             #[derive(
//                 Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration,
//             )]
//             #[repr(i32)]
//             pub enum ResourceStatus {
//                 Unspecified = 0,
//                 Queued = 1,
//                 Processing = 2,
//                 Completed = 3,
//                 Failed = 4,
//                 Partial = 5,
//             }

//             // Internal Document message for processing pipeline
//             #[derive(Clone, PartialEq, ::prost::Message)]
//             pub struct Document {
//                 #[prost(string, tag = "1")]
//                 pub id: String,
//                 #[prost(string, tag = "2")]
//                 pub title: String,
//                 #[prost(string, tag = "3")]
//                 pub content: String,
//                 #[prost(enumeration = "DocumentType", tag = "4")]
//                 pub r#type: i32,
//                 #[prost(string, tag = "5")]
//                 pub source_url: String,
//                 #[prost(map = "string, string", tag = "6")]
//                 pub metadata: ::std::collections::HashMap<String, String>,
//             }

//             #[derive(
//                 Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration,
//             )]
//             #[repr(i32)]
//             pub enum DocumentType {
//                 Unspecified = 0,
//                 Text = 1,
//                 Markdown = 2,
//                 Html = 3,
//                 Pdf = 4,
//                 Code = 5,
//             }
//         }
//     }
// }
